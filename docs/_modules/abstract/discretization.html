
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>abstract.discretization &#8212; TuLiP 1.4.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    
    <script src="../../_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">TuLiP 1.4.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">abstract.discretization</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for abstract.discretization</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2011-2016 by California Institute of Technology</span>
<span class="c1"># Copyright (c) 2016 by The Regents of the University of Michigan</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions</span>
<span class="c1"># are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright</span>
<span class="c1">#    notice, this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="c1">#    notice, this list of conditions and the following disclaimer in the</span>
<span class="c1">#    documentation and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># 3. Neither the name of the copyright holder(s) nor the names of its</span>
<span class="c1">#    contributors may be used to endorse or promote products derived</span>
<span class="c1">#    from this software without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="c1"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="c1"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span>
<span class="c1"># FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE</span>
<span class="c1"># COPYRIGHT HOLDERS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,</span>
<span class="c1"># INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="c1"># (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="c1"># SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="c1"># HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
<span class="c1"># STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
<span class="c1"># IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="c1"># POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Algorithms related to discretization of continuous dynamics.</span>

<span class="sd">See Also</span>
<span class="sd">========</span>
<span class="sd">L{find_controller}</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span> <span class="k">as</span> <span class="n">sp</span>
<span class="kn">import</span> <span class="nn">polytope</span> <span class="k">as</span> <span class="nn">pc</span>

<span class="kn">from</span> <span class="nn">polytope.plot</span> <span class="kn">import</span> <span class="n">plot_partition</span><span class="p">,</span> <span class="n">plot_transition_arrow</span>
<span class="kn">from</span> <span class="nn">tulip</span> <span class="kn">import</span> <span class="n">transys</span> <span class="k">as</span> <span class="n">trs</span>
<span class="kn">from</span> <span class="nn">tulip.hybrid</span> <span class="kn">import</span> <span class="n">LtiSysDyn</span><span class="p">,</span> <span class="n">PwaSysDyn</span>

<span class="kn">from</span> <span class="nn">.prop2partition</span> <span class="kn">import</span> <span class="p">(</span><span class="n">PropPreservingPartition</span><span class="p">,</span>
                             <span class="n">pwa_partition</span><span class="p">,</span> <span class="n">part2convex</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.feasible</span> <span class="kn">import</span> <span class="n">is_feasible</span><span class="p">,</span> <span class="n">solve_feasible</span>
<span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">plot_ts_on_partition</span>

<span class="c1"># inline imports:</span>
<span class="c1">#</span>
<span class="c1"># inline: import matplotlib.pyplot as plt</span>

<span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">class</span> <span class="nc">AbstractSwitched</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstraction of SwitchedSysDyn, with mode-specific and common info.</span>

<span class="sd">    Attributes:</span>

<span class="sd">      - ppp: merged partition, if any</span>
<span class="sd">          Preserves both propositions and dynamics</span>

<span class="sd">      - ts: common TS, if any</span>

<span class="sd">      - ppp2ts: map from C{ppp.regions} to C{ts.states}</span>

<span class="sd">      - modes: dict of {mode: AbstractPwa}</span>

<span class="sd">      - ppp2modes: map from C{ppp.regions} to C{modes[mode].ppp.regions}</span>
<span class="sd">        of the form:</span>

<span class="sd">        {mode: list}</span>

<span class="sd">        where C{list} has same indices as C{ppp.regions} and</span>
<span class="sd">        elements in each C{list} are indices of regions in</span>
<span class="sd">        each C{modes[mode].ppp.regions}.</span>

<span class="sd">        type: dict</span>

<span class="sd">    Each partition corresponds to some mode.</span>
<span class="sd">    (for switched systems)</span>

<span class="sd">    In each mode a L{PwaSysDyn} is active.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ppp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ppp2ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">modes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ppp2modes</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">modes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">modes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ppp</span> <span class="o">=</span> <span class="n">ppp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppp2ts</span> <span class="o">=</span> <span class="n">ppp2ts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modes</span> <span class="o">=</span> <span class="n">modes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppp2modes</span> <span class="o">=</span> <span class="n">ppp2modes</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;Abstraction of switched system</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;common PPP:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppp</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;common ts:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;mode: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, with abstraction:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ab</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">ppp2pwa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return original C{Region} containing C{Region} C{i} in C{mode}.</span>

<span class="sd">        @param mode: key of C{modes}</span>

<span class="sd">        @param i: Region index in common partition C{ppp.regions}.</span>

<span class="sd">        @return: tuple C{(j, region)} of:</span>

<span class="sd">                - index C{j} of C{Region} and</span>
<span class="sd">                - C{Region} object</span>

<span class="sd">            in C{modes[mode].ppp.regions}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">region_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2modes</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ab</span><span class="o">.</span><span class="n">ppp2pwa</span><span class="p">(</span><span class="n">region_idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ppp2sys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return index of active PWA subsystem in C{mode},</span>

<span class="sd">        @param mode: key of C{modes}</span>

<span class="sd">        @param i: Region index in common partition C{ppp.regions}.</span>

<span class="sd">        @return: tuple C{(j, subsystem)} of:</span>

<span class="sd">                - index C{j} of PWA C{subsystem}</span>
<span class="sd">                - L{LtiSysDyn} object C{subsystem}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">region_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2modes</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ab</span><span class="o">.</span><span class="n">ppp2sys</span><span class="p">(</span><span class="n">region_idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show_ts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot mode partitions and merged partition, if one exists.</span>

<span class="sd">        For details see L{AbstractPwa.plot}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">color_seed</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># merged partition exists ?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">:</span>
                <span class="n">env_mode</span><span class="p">,</span> <span class="n">sys_mode</span> <span class="o">=</span> <span class="n">mode</span>
                <span class="n">edge_label</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;env_actions&#39;</span><span class="p">:</span><span class="n">env_mode</span><span class="p">,</span>
                              <span class="s1">&#39;sys_actions&#39;</span><span class="p">:</span><span class="n">sys_mode</span><span class="p">}</span>

                <span class="n">ax</span> <span class="o">=</span> <span class="n">_plot_abstraction</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">show_ts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">color_seed</span><span class="o">=</span><span class="n">color_seed</span>
                <span class="p">)</span>
                <span class="n">plot_ts_on_partition</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ppp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2ts</span><span class="p">,</span>
                    <span class="n">edge_label</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">,</span> <span class="n">ax</span>
                <span class="p">)</span>
                <span class="n">axs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ax</span><span class="p">]</span>

        <span class="c1"># plot mode partitions</span>
        <span class="k">for</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">show_ts</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">,</span> <span class="n">color_seed</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Abstraction for mode: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
            <span class="n">axs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ax</span><span class="p">]</span>

        <span class="c1">#if isinstance(self.ts, dict):</span>
        <span class="c1">#    for ts in self.ts:</span>
        <span class="c1">#        ax = ts.plot()</span>
        <span class="c1">#        axs += [ax]</span>
        <span class="k">return</span> <span class="n">axs</span>

<span class="k">class</span> <span class="nc">AbstractPwa</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Discrete abstraction of PWA dynamics, with attributes:</span>

<span class="sd">      - ppp: Partition into Regions.</span>
<span class="sd">          Each Region corresponds to</span>
<span class="sd">          a discrete state of the abstraction</span>

<span class="sd">          type: L{PropPreservingPartition}</span>

<span class="sd">      - ts: Finite transition system abstracting the continuous system.</span>
<span class="sd">          Each state corresponds to a Region in C{ppp.regions}.</span>
<span class="sd">          It can be fed into discrete synthesis algorithms.</span>

<span class="sd">          type: L{FTS}</span>

<span class="sd">      - ppp2ts: bijection between C{ppp.regions} and C{ts.states}.</span>
<span class="sd">          Has common indices with C{ppp.regions}.</span>
<span class="sd">          Elements are states in C{ts.states}.</span>
<span class="sd">          (usually each state is a str)</span>

<span class="sd">          type: list of states</span>

<span class="sd">      - pwa: system dynamics</span>

<span class="sd">          type: L{PwaSysDyn}</span>

<span class="sd">      - pwa_ppp: partition preserving both:</span>

<span class="sd">            - propositions and</span>
<span class="sd">            - domains of PWA subsystems</span>

<span class="sd">          Used for non-conservative planning.</span>
<span class="sd">          If just L{LtiSysDyn}, then the only difference</span>
<span class="sd">          of C{pwa_ppp} from C{orig_ppp} is convexification.</span>

<span class="sd">          type: L{PropPreservingPartition}</span>

<span class="sd">      - orig_ppp: partition preserving only propositions</span>
<span class="sd">          i.e., agnostic of dynamics</span>

<span class="sd">          type: L{PropPreservingPartition}</span>

<span class="sd">      - disc_params: parameters used in discretization that</span>
<span class="sd">          should be passed to the controller refinement</span>
<span class="sd">          to ensure consistency</span>

<span class="sd">          type: dict</span>

<span class="sd">    If any of the above is not given,</span>
<span class="sd">    then it is initialized to None.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>
<span class="sd">      1. There could be some redundancy in ppp and ofts,</span>
<span class="sd">         in that they are both decorated with propositions.</span>
<span class="sd">         This might be useful to keep each of</span>
<span class="sd">         them as functional units on their own</span>
<span class="sd">         (possible to change later).</span>

<span class="sd">      2. The &#39;Pwa&#39; in L{AbstractPwa} includes L{LtiSysDyn}</span>
<span class="sd">         as a special case.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ppp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ppp2ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pwa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pwa_ppp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ppp2pwa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ppp2sys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orig_ppp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ppp2orig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">disc_params</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">disc_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">disc_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ppp</span> <span class="o">=</span> <span class="n">ppp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppp2ts</span> <span class="o">=</span> <span class="n">ppp2ts</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pwa</span> <span class="o">=</span> <span class="n">pwa</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pwa_ppp</span> <span class="o">=</span> <span class="n">pwa_ppp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2pwa</span> <span class="o">=</span> <span class="n">ppp2pwa</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2sys</span> <span class="o">=</span> <span class="n">ppp2sys</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">orig_ppp</span> <span class="o">=</span> <span class="n">orig_ppp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2orig</span> <span class="o">=</span> <span class="n">ppp2orig</span>

        <span class="c1"># original_regions -&gt; pwa_ppp</span>
        <span class="c1"># ppp2orig -&gt; ppp2pwa_ppp</span>
        <span class="c1"># ppp2pwa -&gt; ppp2pwa_sys</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">disc_params</span> <span class="o">=</span> <span class="n">disc_params</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppp</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="mi">30</span> <span class="o">*</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;Map PPP Regions ---&gt; TS states:</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2other_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppp2ts</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;Map PPP Regions ---&gt; PWA PPP Regions:</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2other_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ppp2pwa</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;Map PPP Regions ---&gt; PWA Subsystems:</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2other_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ppp2sys</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;Map PPP Regions ---&gt; Original PPP Regions:</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2other_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ppp2orig</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;Discretization Options:</span><span class="se">\n\t</span><span class="s1">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">disc_params</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">ts2ppp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">region_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2ts</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp</span><span class="p">[</span><span class="n">region_index</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">region_index</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ppp2trans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the transition set constraint and active subsystem,</span>

<span class="sd">        for non-conservative planning.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reg_idx</span><span class="p">,</span> <span class="n">pwa_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2pwa</span><span class="p">(</span><span class="n">region_index</span><span class="p">)</span>
        <span class="n">sys_idx</span><span class="p">,</span> <span class="n">sys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2sys</span><span class="p">(</span><span class="n">region_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pwa_region</span><span class="p">,</span> <span class="n">sys</span>

    <span class="k">def</span> <span class="nf">ppp2pwa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return dynamics and predicate-preserving region</span>
<span class="sd">        and its index for PWA subsystem active in given region.</span>

<span class="sd">        The returned region is the C{trans_set} used for</span>
<span class="sd">        non-conservative planning.</span>

<span class="sd">        @param region_index: index in C{ppp.regions}.</span>

<span class="sd">        @rtype: C{(i, pwa.pwa_ppp[i])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2pwa</span><span class="p">[</span><span class="n">region_index</span><span class="p">]</span>
        <span class="n">pwa_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pwa_ppp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">pwa_region</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ppp2sys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return index and PWA subsystem active in indexed region.</span>

<span class="sd">        Semantics: j-th sub-system is active in i-th Region,</span>
<span class="sd">        where C{j = ppp2pwa[i]}</span>

<span class="sd">        @param region_index: index in C{ppp.regions}.</span>

<span class="sd">        @rtype: C{(i, pwa.list_subsys[i])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># LtiSysDyn ?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2sys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pwa</span><span class="p">)</span>

        <span class="n">subsystem_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2sys</span><span class="p">[</span><span class="n">region_index</span><span class="p">]</span>
        <span class="n">subsystem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pwa</span><span class="o">.</span><span class="n">list_subsys</span><span class="p">[</span><span class="n">subsystem_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">subsystem_idx</span><span class="p">,</span> <span class="n">subsystem</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ppp2orig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return index and region of original partition.</span>

<span class="sd">        The original partition is w/o any dynamics,</span>
<span class="sd">        not even the PWA domains, only the polytopic predicates.</span>

<span class="sd">        @param region_index: index in C{ppp.regions}.</span>

<span class="sd">        @rtype: C{(i, orig_ppp.regions[i])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2orig</span><span class="p">[</span><span class="n">region_index</span><span class="p">]</span>
        <span class="n">orig_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_ppp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">orig_region</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ppp2other_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ppp2other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ppp2other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">other</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ppp2other</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; -&gt; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">_debug_str_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppp</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;(PWA + Prop)-Preserving Partition&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pwa_ppp</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;Original Prop-Preserving Partition&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_ppp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show_ts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">color_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot partition and optionally feasible transitions.</span>

<span class="sd">        @param show_ts: plot feasible transitions on partition</span>
<span class="sd">        @type show_ts: bool</span>

<span class="sd">        @param only_adjacent: plot feasible transitions only</span>
<span class="sd">            between adjacent regions. This reduces clutter,</span>
<span class="sd">            but if horizon &gt; 1 and not all horizon used,</span>
<span class="sd">            then some transitions could be hidden.</span>
<span class="sd">        @param only_adjacent: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">_plot_abstraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show_ts</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">,</span>
                               <span class="n">color_seed</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">verify_transitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;verifying transitions...&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">from_state</span><span class="p">,</span> <span class="n">to_state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">transitions</span><span class="p">():</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">from_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts2ppp</span><span class="p">(</span><span class="n">from_state</span><span class="p">)</span>
            <span class="n">j</span><span class="p">,</span> <span class="n">to_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts2ppp</span><span class="p">(</span><span class="n">to_state</span><span class="p">)</span>

            <span class="n">trans_set</span><span class="p">,</span> <span class="n">sys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2trans</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;close_loop&#39;</span><span class="p">,</span> <span class="s1">&#39;use_all_horizon&#39;</span><span class="p">}</span>
            <span class="n">disc_params</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">disc_params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                           <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">params</span><span class="p">}</span>

            <span class="n">s0</span> <span class="o">=</span> <span class="n">solve_feasible</span><span class="p">(</span><span class="n">from_region</span><span class="p">,</span> <span class="n">to_region</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span>
                                <span class="n">trans_set</span><span class="o">=</span><span class="n">trans_set</span><span class="p">,</span> <span class="o">**</span><span class="n">disc_params</span><span class="p">)</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; ---&gt; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">from_region</span> <span class="o">&lt;=</span> <span class="n">s0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;incorrect transition: &#39;</span> <span class="o">+</span> <span class="n">msg</span><span class="p">)</span>

                <span class="n">isect</span> <span class="o">=</span> <span class="n">from_region</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">isect</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span><span class="n">from_region</span><span class="o">.</span><span class="n">volume</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;intersection volume: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; %&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;correct transition: &#39;</span> <span class="o">+</span> <span class="n">msg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_plot_abstraction</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">show_ts</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">,</span> <span class="n">color_seed</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ab</span><span class="o">.</span><span class="n">ppp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ab</span><span class="o">.</span><span class="n">ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Either ppp or ts is None.&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">show_ts</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">ts</span>
        <span class="n">ppp2ts</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">ppp2ts</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ppp2ts</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">ppp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
        <span class="n">ts</span><span class="p">,</span> <span class="n">ppp2ts</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="o">=</span><span class="n">only_adjacent</span><span class="p">,</span>
        <span class="n">color_seed</span><span class="o">=</span><span class="n">color_seed</span>
    <span class="p">)</span>

    <span class="c1">#ax = self.ts.plot()</span>

    <span class="k">return</span> <span class="n">ax</span>

<div class="viewcode-block" id="discretize"><a class="viewcode-back" href="../../tutorial.html#abstract.discretize">[docs]</a><span class="k">def</span> <span class="nf">discretize</span><span class="p">(</span>
    <span class="n">part</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_cell_volume</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">closed_loop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">conservative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_num_poly</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">use_all_horizon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">trans_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">remove_trans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">plotit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_img</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cont_props</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_every</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">simu_type</span><span class="o">=</span><span class="s1">&#39;bi&#39;</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Refine the partition via bisimulation</span>
<span class="sd">    or dual-simulation algorithms, and establish transitions</span>
<span class="sd">    based on reachability analysis.</span>

<span class="sd">    Reference</span>
<span class="sd">    =========</span>
<span class="sd">    U{[NOTM12]</span>
<span class="sd">    &lt;https://tulip-control.sourceforge.io/doc/bibliography.html#notm12&gt;}</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    L{prop2partition.pwa_partition}, L{prop2partition.part2convex}</span>

<span class="sd">    @param part: L{PropPreservingPartition} object</span>
<span class="sd">    @param ssys: L{LtiSysDyn} or L{PwaSysDyn} object</span>
<span class="sd">    @param N: horizon length</span>
<span class="sd">    @param min_cell_volume: the minimum volume of cells in the resulting</span>
<span class="sd">        partition.</span>
<span class="sd">    @param closed_loop: boolean indicating whether the `closed loop`</span>
<span class="sd">        algorithm should be used. default True.</span>
<span class="sd">    @param conservative: if true, force sequence in reachability analysis</span>
<span class="sd">        to stay inside starting cell. If false, safety</span>
<span class="sd">        is ensured by keeping the sequence inside a convexified</span>
<span class="sd">        version of the original proposition preserving cell.</span>
<span class="sd">    @param max_num_poly: maximum number of polytopes in a region to use in</span>
<span class="sd">        reachability analysis.</span>
<span class="sd">    @param use_all_horizon: in closed loop algorithm: if we should look</span>
<span class="sd">        for reachability also in less than N steps.</span>
<span class="sd">    @param trans_length: the number of polytopes allowed to cross in a</span>
<span class="sd">        transition.  a value of 1 checks transitions</span>
<span class="sd">        only between neighbors, a value of 2 checks</span>
<span class="sd">        neighbors of neighbors and so on.</span>
<span class="sd">    @param remove_trans: if True, remove found transitions between</span>
<span class="sd">        non-neighbors.</span>
<span class="sd">    @param abs_tol: maximum volume for an &quot;empty&quot; polytope</span>

<span class="sd">    @param plotit: plot partitioning as it evolves</span>
<span class="sd">    @type plotit: boolean,</span>
<span class="sd">        default = False</span>

<span class="sd">    @param save_img: save snapshots of partitioning to PDF files,</span>
<span class="sd">        requires plotit=True</span>
<span class="sd">    @type save_img: boolean,</span>
<span class="sd">        default = False</span>

<span class="sd">    @param cont_props: continuous propositions to plot</span>
<span class="sd">    @type cont_props: list of C{Polytope}</span>

<span class="sd">    @param simu_type: if &#39;bi&#39;, use bisimulation partition; if &#39;dual&#39;,</span>
<span class="sd">        use dual-simulation partition</span>
<span class="sd">    @type simu_type: string,</span>
<span class="sd">        default = &#39;bi&#39;</span>

<span class="sd">    @rtype: L{AbstractPwa}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">simu_type</span> <span class="o">==</span> <span class="s1">&#39;bi&#39;</span><span class="p">:</span>
        <span class="n">AbstractPwa</span> <span class="o">=</span> <span class="n">_discretize_bi</span><span class="p">(</span>
            <span class="n">part</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">min_cell_volume</span><span class="p">,</span>
            <span class="n">closed_loop</span><span class="p">,</span> <span class="n">conservative</span><span class="p">,</span>
            <span class="n">max_num_poly</span><span class="p">,</span> <span class="n">use_all_horizon</span><span class="p">,</span>
            <span class="n">trans_length</span><span class="p">,</span> <span class="n">remove_trans</span><span class="p">,</span>
            <span class="n">abs_tol</span><span class="p">,</span>
            <span class="n">plotit</span><span class="p">,</span> <span class="n">save_img</span><span class="p">,</span> <span class="n">cont_props</span><span class="p">,</span>
            <span class="n">plot_every</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">simu_type</span> <span class="o">==</span> <span class="s1">&#39;dual&#39;</span><span class="p">:</span>
        <span class="n">AbstractPwa</span> <span class="o">=</span> <span class="n">_discretize_dual</span><span class="p">(</span>
            <span class="n">part</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">min_cell_volume</span><span class="p">,</span>
            <span class="n">closed_loop</span><span class="p">,</span> <span class="n">conservative</span><span class="p">,</span>
            <span class="n">max_num_poly</span><span class="p">,</span> <span class="n">use_all_horizon</span><span class="p">,</span>
            <span class="n">trans_length</span><span class="p">,</span> <span class="n">remove_trans</span><span class="p">,</span>
            <span class="n">abs_tol</span><span class="p">,</span>
            <span class="n">plotit</span><span class="p">,</span> <span class="n">save_img</span><span class="p">,</span> <span class="n">cont_props</span><span class="p">,</span>
            <span class="n">plot_every</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Unknown simulation type: &quot;</span><span class="si">{st}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">st</span><span class="o">=</span><span class="n">simu_type</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">AbstractPwa</span></div>

<span class="k">def</span> <span class="nf">_discretize_bi</span><span class="p">(</span>
    <span class="n">part</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_cell_volume</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">closed_loop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">conservative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_num_poly</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">use_all_horizon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">trans_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">remove_trans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">plotit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_img</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cont_props</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_every</span><span class="o">=</span><span class="mi">1</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Refine the partition and establish transitions</span>
<span class="sd">    based on reachability analysis. Use bi-simulation algorithm.</span>

<span class="sd">    Reference</span>
<span class="sd">    =========</span>
<span class="sd">    1. U{[NOTM12]</span>
<span class="sd">    &lt;https://tulip-control.sourceforge.io/doc/bibliography.html#notm12&gt;}</span>
<span class="sd">    2. Wagenmaker, A. J.; Ozay, N.</span>
<span class="sd">       &quot;A Bisimulation-like Algorithm for Abstracting Control Systems.&quot;</span>
<span class="sd">       54th Annual Allerton Conference on CCC 2016</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    L{prop2partition.pwa_partition}, L{prop2partition.part2convex}</span>

<span class="sd">    @param part: L{PropPreservingPartition} object</span>
<span class="sd">    @param ssys: L{LtiSysDyn} or L{PwaSysDyn} object</span>
<span class="sd">    @param N: horizon length</span>
<span class="sd">    @param min_cell_volume: the minimum volume of cells in the resulting</span>
<span class="sd">        partition.</span>
<span class="sd">    @param closed_loop: boolean indicating whether the `closed loop`</span>
<span class="sd">        algorithm should be used. default True.</span>
<span class="sd">    @param conservative: if true, force sequence in reachability analysis</span>
<span class="sd">        to stay inside starting cell. If false, safety</span>
<span class="sd">        is ensured by keeping the sequence inside a convexified</span>
<span class="sd">        version of the original proposition preserving cell.</span>
<span class="sd">    @param max_num_poly: maximum number of polytopes in a region to use in</span>
<span class="sd">        reachability analysis.</span>
<span class="sd">    @param use_all_horizon: in closed loop algorithm: if we should look</span>
<span class="sd">        for reachability also in less than N steps.</span>
<span class="sd">    @param trans_length: the number of polytopes allowed to cross in a</span>
<span class="sd">        transition.  a value of 1 checks transitions</span>
<span class="sd">        only between neighbors, a value of 2 checks</span>
<span class="sd">        neighbors of neighbors and so on.</span>
<span class="sd">    @param remove_trans: if True, remove found transitions between</span>
<span class="sd">        non-neighbors.</span>
<span class="sd">    @param abs_tol: maximum volume for an &quot;empty&quot; polytope</span>

<span class="sd">    @param plotit: plot partitioning as it evolves</span>
<span class="sd">    @type plotit: boolean,</span>
<span class="sd">        default = False</span>

<span class="sd">    @param save_img: save snapshots of partitioning to PDF files,</span>
<span class="sd">        requires plotit=True</span>
<span class="sd">    @type save_img: boolean,</span>
<span class="sd">        default = False</span>

<span class="sd">    @param cont_props: continuous propositions to plot</span>
<span class="sd">    @type cont_props: list of C{Polytope}</span>

<span class="sd">    @rtype: L{AbstractPwa}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">orig_ppp</span> <span class="o">=</span> <span class="n">part</span>
    <span class="n">min_cell_volume</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_cell_volume</span> <span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
    <span class="n">ispwa</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ssys</span><span class="p">,</span> <span class="n">PwaSysDyn</span><span class="p">)</span>
    <span class="n">islti</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ssys</span><span class="p">,</span> <span class="n">LtiSysDyn</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
        <span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">ppp2pwa</span><span class="p">,</span> <span class="n">part2orig</span><span class="p">)</span> <span class="o">=</span> <span class="n">pwa_partition</span><span class="p">(</span><span class="n">ssys</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">part2orig</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">))</span>
    <span class="c1"># Save original polytopes, require them to be convex</span>
    <span class="k">if</span> <span class="n">conservative</span><span class="p">:</span>
        <span class="n">orig_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">new2old</span><span class="p">)</span> <span class="o">=</span> <span class="n">part2convex</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="c1"># convexify</span>
        <span class="n">part2orig</span> <span class="o">=</span> <span class="p">[</span><span class="n">part2orig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new2old</span><span class="p">]</span>

        <span class="c1"># map new regions to pwa subsystems</span>
        <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
            <span class="n">ppp2pwa</span> <span class="o">=</span> <span class="p">[</span><span class="n">ppp2pwa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new2old</span><span class="p">]</span>

        <span class="n">remove_trans</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># already allowed in nonconservative</span>
        <span class="n">orig_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">orig_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">orig_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;discretize: &quot;</span>
                    <span class="s2">&quot;problem in convexification&quot;</span><span class="p">)</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orig_list</span><span class="p">)))</span>
    <span class="c1"># Cheby radius of disturbance set</span>
    <span class="c1"># (defined within the loop for pwa systems)</span>
    <span class="k">if</span> <span class="n">islti</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssys</span><span class="o">.</span><span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="n">ssys</span><span class="o">.</span><span class="n">Wset</span><span class="o">.</span><span class="n">chebR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="c1"># Initialize matrix for pairs to check</span>
    <span class="n">IJ</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Starting IJ: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span> <span class="p">)</span>
    <span class="c1"># next line omitted in discretize_overlap</span>
    <span class="n">IJ</span> <span class="o">=</span> <span class="n">reachable_within</span><span class="p">(</span><span class="n">trans_length</span><span class="p">,</span> <span class="n">IJ</span><span class="p">,</span>
                          <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
    <span class="c1"># Initialize output</span>
    <span class="n">num_regions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
    <span class="n">transitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">[</span><span class="n">num_regions</span><span class="p">,</span> <span class="n">num_regions</span><span class="p">],</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span>
    <span class="p">)</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">regions</span><span class="p">)</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="c1"># next 2 lines omitted in discretize_overlap</span>
    <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
        <span class="n">subsys_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ppp2pwa</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subsys_list</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">ssys</span>
    <span class="c1"># init graphics</span>
    <span class="k">if</span> <span class="n">plotit</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
            <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
            <span class="n">file_extension</span> <span class="o">=</span> <span class="s1">&#39;pdf&#39;</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;failed to import matplotlib&#39;</span><span class="p">)</span>
            <span class="n">plt</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">iter_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># List of how many &quot;new&quot; regions</span>
    <span class="c1"># have been created for each region</span>
    <span class="c1"># and a list of original number of neighbors</span>
    <span class="c1">#num_new_reg = np.zeros(len(orig_list))</span>
    <span class="c1">#num_orig_neigh = np.sum(adj, axis=1).flatten() - 1</span>
    <span class="n">progress</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># Do the abstraction</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span>
        <span class="c1"># i,j swapped in discretize_overlap</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">IJ</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">sj</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">si_tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
        <span class="n">sj_tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">sj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="n">ssys</span><span class="o">.</span><span class="n">list_subsys</span><span class="p">[</span><span class="n">subsys_list</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rd</span><span class="p">,</span> <span class="n">xd</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">Wset</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rd</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="n">conservative</span><span class="p">:</span>
            <span class="c1"># Don&#39;t use trans_set</span>
            <span class="n">trans_set</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use original cell as trans_set</span>
            <span class="n">trans_set</span> <span class="o">=</span> <span class="n">orig_list</span><span class="p">[</span><span class="n">orig</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">S0</span> <span class="o">=</span> <span class="n">solve_feasible</span><span class="p">(</span>
            <span class="n">si</span><span class="p">,</span> <span class="n">sj</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">closed_loop</span><span class="p">,</span>
            <span class="n">use_all_horizon</span><span class="p">,</span> <span class="n">trans_set</span><span class="p">,</span> <span class="n">max_num_poly</span>
        <span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Working with partition cells: </span><span class="si">{i}</span><span class="s1">, </span><span class="si">{j}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                                                <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="si">{i}</span><span class="s1"> (#polytopes = </span><span class="si">{num}</span><span class="s1">), and:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                                                <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">si</span><span class="p">))</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="si">{j}</span><span class="s1"> (#polytopes = </span><span class="si">{num}</span><span class="s1">)</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
                                                <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">sj</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> with active subsystem: &#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">{sys}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sys</span><span class="o">=</span><span class="n">subsys_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Computed reachable set S0 with volume: &#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">{vol}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vol</span><span class="o">=</span><span class="n">S0</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1">#logger.debug(r&#39;si \cap s0&#39;)</span>
        <span class="n">isect</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">S0</span><span class="p">)</span>
        <span class="n">vol1</span> <span class="o">=</span> <span class="n">isect</span><span class="o">.</span><span class="n">volume</span>
        <span class="n">risect</span><span class="p">,</span> <span class="n">xi</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
        <span class="c1">#logger.debug(r&#39;si \ s0&#39;)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">S0</span><span class="p">)</span>
        <span class="n">vol2</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">volume</span>
        <span class="n">rdiff</span><span class="p">,</span> <span class="n">xd</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
        <span class="c1"># if pc.is_fulldim(pc.Region([isect]).intersect(diff)):</span>
        <span class="c1">#     logging.getLogger(&#39;tulip.polytope&#39;).setLevel(logging.DEBUG)</span>
        <span class="c1">#     diff = pc.mldivide(si, S0, save=True)</span>
        <span class="c1">#</span>
        <span class="c1">#     ax = S0.plot()</span>
        <span class="c1">#     ax.axis([0.0, 1.0, 0.0, 2.0])</span>
        <span class="c1">#     ax.figure.savefig(&#39;./img/s0.pdf&#39;)</span>
        <span class="c1">#</span>
        <span class="c1">#     ax = si.plot()</span>
        <span class="c1">#     ax.axis([0.0, 1.0, 0.0, 2.0])</span>
        <span class="c1">#     ax.figure.savefig(&#39;./img/si.pdf&#39;)</span>
        <span class="c1">#</span>
        <span class="c1">#     ax = isect.plot()</span>
        <span class="c1">#     ax.axis([0.0, 1.0, 0.0, 2.0])</span>
        <span class="c1">#     ax.figure.savefig(&#39;./img/isect.pdf&#39;)</span>
        <span class="c1">#</span>
        <span class="c1">#     ax = diff.plot()</span>
        <span class="c1">#     ax.axis([0.0, 1.0, 0.0, 2.0])</span>
        <span class="c1">#     ax.figure.savefig(&#39;./img/diff.pdf&#39;)</span>
        <span class="c1">#</span>
        <span class="c1">#     ax = isect.intersect(diff).plot()</span>
        <span class="c1">#     ax.axis([0.0, 1.0, 0.0, 2.0])</span>
        <span class="c1">#     ax.figure.savefig(&#39;./img/diff_cap_isect.pdf&#39;)</span>
        <span class="c1">#</span>
        <span class="c1">#     logger.error(r&#39;Intersection \cap Difference != \emptyset&#39;)</span>
        <span class="c1">#</span>
        <span class="c1">#     assert(False)</span>
        <span class="k">if</span> <span class="n">vol1</span> <span class="o">&lt;=</span> <span class="n">min_cell_volume</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> too small: si </span><span class="se">\\</span><span class="s1">cap Pre(sj), &#39;</span>
                           <span class="s1">&#39;so discard intersection&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vol1</span> <span class="o">&lt;=</span> <span class="n">min_cell_volume</span> <span class="ow">and</span> <span class="n">isect</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> discarded non-empty intersection: &#39;</span>
                           <span class="s1">&#39;consider reducing min_cell_volume&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vol2</span> <span class="o">&lt;=</span> <span class="n">min_cell_volume</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> too small: si </span><span class="se">\\</span><span class="s1"> Pre(sj), so not reached it&#39;</span><span class="p">)</span>
        <span class="c1"># We don&#39;t want our partitions to be smaller than the disturbance set</span>
        <span class="c1"># Could be a problem since cheby radius is calculated for smallest</span>
        <span class="c1"># convex polytope, so if we have a region we might throw away a good</span>
        <span class="c1"># cell.</span>
        <span class="k">if</span> <span class="p">(</span>
                <span class="n">vol1</span> <span class="o">&gt;</span> <span class="n">min_cell_volume</span> <span class="ow">and</span>
                <span class="n">risect</span> <span class="o">&gt;</span> <span class="n">rd</span> <span class="ow">and</span>
                <span class="n">vol2</span> <span class="o">&gt;</span> <span class="n">min_cell_volume</span> <span class="ow">and</span>
                <span class="n">rdiff</span> <span class="o">&gt;</span> <span class="n">rd</span><span class="p">):</span>
            <span class="c1"># Make sure new areas are Regions and add proposition lists</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">isect</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">Region</span><span class="p">([</span><span class="n">isect</span><span class="p">],</span> <span class="n">si</span><span class="o">.</span><span class="n">props</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isect</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">Region</span><span class="p">([</span><span class="n">diff</span><span class="p">],</span> <span class="n">si</span><span class="o">.</span><span class="n">props</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">diff</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># replace si by intersection (single state)</span>
            <span class="n">isect_list</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
            <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">isect_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># cut difference into connected pieces</span>
            <span class="n">difflist</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
            <span class="n">difflist</span> <span class="o">+=</span> <span class="n">isect_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="c1">#            n_isect = len(isect_list) -1</span>
            <span class="n">num_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">difflist</span><span class="p">)</span>
            <span class="c1"># add each piece, as a new state</span>
            <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">difflist</span><span class="p">:</span>
                <span class="n">sol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
                <span class="c1"># keep track of PWA subsystems map to new states</span>
                <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
                    <span class="n">subsys_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subsys_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">n_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="n">new_idx</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cells</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_cells</span><span class="o">-</span><span class="n">num_new</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;Update transition matrix&quot;&quot;&quot;</span>
            <span class="n">transitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">transitions</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">num_new</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_cells</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                <span class="c1">#transitions[:, r] = transitions[:, i]</span>
                <span class="c1"># All sets reachable from start are reachable from both part&#39;s</span>
                <span class="c1"># except possibly the new part</span>
                <span class="n">transitions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># sol[j] is reachable from intersection of sol[i] and S0</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># sol[j] is reachable from each piece os S0 \cap sol[i]</span>
                <span class="c1">#for k in range(n_cells-n_isect-2, n_cells):</span>
                <span class="c1">#    transitions[j, k] = 1</span>
            <span class="sd">&quot;&quot;&quot;Update adjacency matrix&quot;&quot;&quot;</span>
            <span class="n">old_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># reset new adjacencies</span>
            <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_cells</span> <span class="o">-</span><span class="n">num_new</span><span class="p">])</span>
            <span class="n">adj</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_cells</span> <span class="o">-</span><span class="n">num_new</span><span class="p">])</span>
            <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_new</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">conservative</span><span class="p">:</span>
                    <span class="n">orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">orig</span><span class="p">,</span> <span class="n">orig</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="c1"># adjacencies between pieces of isect and diff</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="n">k</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">pc</span><span class="o">.</span><span class="n">is_adjacent</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t\n</span><span class="s1"> Adding states </span><span class="si">{i}</span><span class="s1"> and &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">{r}</span><span class="s1"> and &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">old_adj</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n_cells</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># Every &quot;old&quot; neighbor must be the neighbor</span>
                <span class="c1"># of at least one of the new</span>
                <span class="k">if</span> <span class="n">pc</span><span class="o">.</span><span class="n">is_adjacent</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                    <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">adj</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">remove_trans</span> <span class="ow">and</span> <span class="p">(</span><span class="n">trans_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># Actively remove transitions between non-neighbors</span>
                    <span class="n">transitions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">transitions</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pc</span><span class="o">.</span><span class="n">is_adjacent</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">remove_trans</span> <span class="ow">and</span> <span class="p">(</span><span class="n">trans_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="c1"># Actively remove transitions between non-neighbors</span>
                        <span class="n">transitions</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">transitions</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="sd">&quot;&quot;&quot;Update IJ matrix&quot;&quot;&quot;</span>
            <span class="n">IJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">num_new</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
            <span class="n">adj_k</span> <span class="o">=</span> <span class="n">reachable_within</span><span class="p">(</span><span class="n">trans_length</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">adj</span><span class="p">)</span>
            <span class="n">sym_adj_change</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="n">adj_k</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                <span class="n">sym_adj_change</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="n">adj_k</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1"> Updated adj: </span><span class="se">\n</span><span class="si">{adj}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">adj</span><span class="o">=</span><span class="n">adj</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1"> Updated trans: </span><span class="se">\n</span><span class="si">{trans}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trans</span><span class="o">=</span>
                                              <span class="n">transitions</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1"> Updated IJ: </span><span class="se">\n</span><span class="si">{IJ}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">IJ</span><span class="o">=</span><span class="n">IJ</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Divided region: </span><span class="si">{i}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">vol2</span> <span class="o">&lt;</span> <span class="n">abs_tol</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Found: </span><span class="si">{i}</span><span class="s1"> ---&gt; </span><span class="si">{j}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">))</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Unreachable: </span><span class="si">{i}</span><span class="s1"> --X--&gt; </span><span class="si">{j}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1"> diff vol: </span><span class="si">{vol2}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vol2</span><span class="o">=</span><span class="n">vol2</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1"> intersect vol: </span><span class="si">{vol1}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vol1</span><span class="o">=</span><span class="n">vol1</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> unreachable</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># check to avoid overlapping Regions</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">tmp_part</span> <span class="o">=</span> <span class="n">PropPreservingPartition</span><span class="p">(</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                <span class="n">regions</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span> <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span>
                <span class="n">prop_regions</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span>
            <span class="p">)</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">tmp_part</span><span class="o">.</span><span class="n">is_partition</span><span class="p">()</span> <span class="p">)</span>

        <span class="n">n_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
        <span class="n">progress_ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span><span class="n">n_cells</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">progress</span> <span class="o">+=</span> <span class="p">[</span><span class="n">progress_ratio</span><span class="p">]</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> total # polytopes: </span><span class="si">{n_cells}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_cells</span><span class="o">=</span><span class="n">n_cells</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> progress ratio: </span><span class="si">{pr}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pr</span><span class="o">=</span><span class="n">progress_ratio</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">iter_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># no plotting ?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">plotit</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">plt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">plot_partition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">iter_count</span> <span class="o">%</span> <span class="n">plot_every</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">tmp_part</span> <span class="o">=</span> <span class="n">PropPreservingPartition</span><span class="p">(</span>
            <span class="n">domain</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
            <span class="n">regions</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span> <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span>
            <span class="n">prop_regions</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span>
        <span class="p">)</span>
        <span class="c1"># plot pair under reachability check</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">si_tmp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>
        <span class="n">sj_tmp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">plot_transition_arrow</span><span class="p">(</span><span class="n">si_tmp</span><span class="p">,</span> <span class="n">sj_tmp</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span>
        <span class="n">S0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="c1"># plot partition</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">plot_partition</span><span class="p">(</span><span class="n">tmp_part</span><span class="p">,</span> <span class="n">transitions</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span> <span class="n">color_seed</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
        <span class="c1"># plot dynamics</span>
        <span class="n">ssys</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">show_domain</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># plot hatched continuous propositions</span>
        <span class="n">part</span><span class="o">.</span><span class="n">plot_props</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="c1"># scale view based on domain,</span>
        <span class="c1"># not only the current polytopes si, sj</span>
        <span class="n">l</span><span class="p">,</span><span class="n">u</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">save_img</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;movie&#39;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iter_count</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">fname</span> <span class="o">+=</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">file_extension</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">250</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">new_part</span> <span class="o">=</span> <span class="n">PropPreservingPartition</span><span class="p">(</span>
        <span class="n">domain</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
        <span class="n">regions</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span> <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span>
        <span class="n">prop_regions</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span>
    <span class="p">)</span>
    <span class="c1"># check completeness of adjacency matrix</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">tmp_part</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">new_part</span><span class="p">)</span>
        <span class="n">tmp_part</span><span class="o">.</span><span class="n">compute_adj</span><span class="p">()</span>
    <span class="c1"># Generate transition system and add transitions</span>
    <span class="n">ofts</span> <span class="o">=</span> <span class="n">trs</span><span class="o">.</span><span class="n">FTS</span><span class="p">()</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">transitions</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ofts_states</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">ofts</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">ofts_states</span><span class="p">)</span>
    <span class="n">ofts</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">add_adj</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">ofts_states</span><span class="p">)</span>
    <span class="c1"># Decorate TS with state labels</span>
    <span class="n">atomic_propositions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">)</span>
    <span class="n">ofts</span><span class="o">.</span><span class="n">atomic_propositions</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">atomic_propositions</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ofts_states</span><span class="p">,</span> <span class="n">sol</span><span class="p">):</span>
        <span class="n">state_prop</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ofts</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">ap</span><span class="o">=</span><span class="n">state_prop</span><span class="p">)</span>
    <span class="n">param</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;N&#39;</span><span class="p">:</span><span class="n">N</span><span class="p">,</span>
        <span class="s1">&#39;trans_length&#39;</span><span class="p">:</span><span class="n">trans_length</span><span class="p">,</span>
        <span class="s1">&#39;closed_loop&#39;</span><span class="p">:</span><span class="n">closed_loop</span><span class="p">,</span>
        <span class="s1">&#39;conservative&#39;</span><span class="p">:</span><span class="n">conservative</span><span class="p">,</span>
        <span class="s1">&#39;use_all_horizon&#39;</span><span class="p">:</span><span class="n">use_all_horizon</span><span class="p">,</span>
        <span class="s1">&#39;min_cell_volume&#39;</span><span class="p">:</span><span class="n">min_cell_volume</span><span class="p">,</span>
        <span class="s1">&#39;max_num_poly&#39;</span><span class="p">:</span><span class="n">max_num_poly</span>
    <span class="p">}</span>
    <span class="n">ppp2orig</span> <span class="o">=</span> <span class="p">[</span><span class="n">part2orig</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">orig</span><span class="p">]</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Total abstraction time: </span><span class="si">{time}</span><span class="s1">[sec]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">=</span>
             <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">save_img</span> <span class="ow">and</span> <span class="n">plt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;iteration&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;progress ratio&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;progress.pdf&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AbstractPwa</span><span class="p">(</span>
        <span class="n">ppp</span><span class="o">=</span><span class="n">new_part</span><span class="p">,</span>
        <span class="n">ts</span><span class="o">=</span><span class="n">ofts</span><span class="p">,</span>
        <span class="n">ppp2ts</span><span class="o">=</span><span class="n">ofts_states</span><span class="p">,</span>
        <span class="n">pwa</span><span class="o">=</span><span class="n">ssys</span><span class="p">,</span>
        <span class="n">pwa_ppp</span><span class="o">=</span><span class="n">part</span><span class="p">,</span>
        <span class="n">ppp2pwa</span><span class="o">=</span><span class="n">orig</span><span class="p">,</span>
        <span class="n">ppp2sys</span><span class="o">=</span><span class="n">subsys_list</span><span class="p">,</span>
        <span class="n">orig_ppp</span><span class="o">=</span><span class="n">orig_ppp</span><span class="p">,</span>
        <span class="n">ppp2orig</span><span class="o">=</span><span class="n">ppp2orig</span><span class="p">,</span>
        <span class="n">disc_params</span><span class="o">=</span><span class="n">param</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">_discretize_dual</span><span class="p">(</span>
    <span class="n">part</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_cell_volume</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">closed_loop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">conservative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_num_poly</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">use_all_horizon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">trans_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">remove_trans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">plotit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_img</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cont_props</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_every</span><span class="o">=</span><span class="mi">1</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Refine the partition and establish transitions</span>
<span class="sd">    based on reachability analysis. Use dual-simulation algorithm.</span>

<span class="sd">    Reference</span>
<span class="sd">    =========</span>
<span class="sd">    1. U{[NOTM12]</span>
<span class="sd">    &lt;https://tulip-control.sourceforge.io/doc/bibliography.html#notm12&gt;}</span>
<span class="sd">    2. Wagenmaker, A. J.; Ozay, N.</span>
<span class="sd">       &quot;A Bisimulation-like Algorithm for Abstracting Control Systems.&quot;</span>
<span class="sd">       54th Annual Allerton Conference on CCC 2016</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    L{prop2partition.pwa_partition}, L{prop2partition.part2convex}</span>

<span class="sd">    @param part: L{PropPreservingPartition} object</span>
<span class="sd">    @param ssys: L{LtiSysDyn} or L{PwaSysDyn} object</span>
<span class="sd">    @param N: horizon length</span>
<span class="sd">    @param min_cell_volume: the minimum volume of cells in the resulting</span>
<span class="sd">        partition.</span>
<span class="sd">    @param closed_loop: boolean indicating whether the `closed loop`</span>
<span class="sd">        algorithm should be used. default True.</span>
<span class="sd">    @param conservative: if true, force sequence in reachability analysis</span>
<span class="sd">        to stay inside starting cell. If false, safety</span>
<span class="sd">        is ensured by keeping the sequence inside a convexified</span>
<span class="sd">        version of the original proposition preserving cell.</span>
<span class="sd">    @param max_num_poly: maximum number of polytopes in a region to use in</span>
<span class="sd">        reachability analysis.</span>
<span class="sd">    @param use_all_horizon: in closed loop algorithm: if we should look</span>
<span class="sd">        for reachability also in less than N steps.</span>
<span class="sd">    @param trans_length: the number of polytopes allowed to cross in a</span>
<span class="sd">        transition.  a value of 1 checks transitions</span>
<span class="sd">        only between neighbors, a value of 2 checks</span>
<span class="sd">        neighbors of neighbors and so on.</span>
<span class="sd">    @param remove_trans: if True, remove found transitions between</span>
<span class="sd">        non-neighbors.</span>
<span class="sd">    @param abs_tol: maximum volume for an &quot;empty&quot; polytope</span>

<span class="sd">    @param plotit: plot partitioning as it evolves</span>
<span class="sd">    @type plotit: boolean,</span>
<span class="sd">        default = False</span>

<span class="sd">    @param save_img: save snapshots of partitioning to PDF files,</span>
<span class="sd">        requires plotit=True</span>
<span class="sd">    @type save_img: boolean,</span>
<span class="sd">        default = False</span>

<span class="sd">    @param cont_props: continuous propositions to plot</span>
<span class="sd">    @type cont_props: list of C{Polytope}</span>

<span class="sd">    @param simu_type: flag used to choose abstraction algorithm</span>
<span class="sd">        (bisimulation or dual-simulation).</span>
<span class="sd">    @type simu_type: string, &#39;bi&#39; or &#39;dual&#39;</span>
<span class="sd">        default = &#39;bi&#39;</span>

<span class="sd">    @rtype: L{AbstractPwa}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">orig_ppp</span> <span class="o">=</span> <span class="n">part</span>
    <span class="n">min_cell_volume</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_cell_volume</span> <span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
    <span class="n">ispwa</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ssys</span><span class="p">,</span> <span class="n">PwaSysDyn</span><span class="p">)</span>
    <span class="n">islti</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ssys</span><span class="p">,</span> <span class="n">LtiSysDyn</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
        <span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">ppp2pwa</span><span class="p">,</span> <span class="n">part2orig</span><span class="p">)</span> <span class="o">=</span> <span class="n">pwa_partition</span><span class="p">(</span><span class="n">ssys</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">part2orig</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">))</span>
    <span class="c1"># Save original polytopes, require them to be convex</span>
    <span class="k">if</span> <span class="n">conservative</span><span class="p">:</span>
        <span class="n">orig_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">new2old</span><span class="p">)</span> <span class="o">=</span> <span class="n">part2convex</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="c1"># convexify</span>
        <span class="n">part2orig</span> <span class="o">=</span> <span class="p">[</span><span class="n">part2orig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new2old</span><span class="p">]</span>

        <span class="c1"># map new regions to pwa subsystems</span>
        <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
            <span class="n">ppp2pwa</span> <span class="o">=</span> <span class="p">[</span><span class="n">ppp2pwa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new2old</span><span class="p">]</span>
        <span class="n">remove_trans</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># already allowed in nonconservative</span>
        <span class="n">orig_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">orig_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">orig_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;discretize: &quot;</span>
                    <span class="s2">&quot;problem in convexification&quot;</span><span class="p">)</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orig_list</span><span class="p">)))</span>
    <span class="c1"># Cheby radius of disturbance set</span>
    <span class="c1"># (defined within the loop for pwa systems)</span>
    <span class="k">if</span> <span class="n">islti</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssys</span><span class="o">.</span><span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="n">ssys</span><span class="o">.</span><span class="n">Wset</span><span class="o">.</span><span class="n">chebR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="c1"># Initialize matrix for pairs to check</span>
    <span class="n">IJ</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Starting IJ: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span> <span class="p">)</span>
    <span class="c1"># next line omitted in discretize_overlap</span>
    <span class="n">IJ</span> <span class="o">=</span> <span class="n">reachable_within</span><span class="p">(</span><span class="n">trans_length</span><span class="p">,</span> <span class="n">IJ</span><span class="p">,</span>
                          <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
    <span class="c1"># Initialize output</span>
    <span class="n">num_regions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
    <span class="n">transitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">[</span><span class="n">num_regions</span><span class="p">,</span> <span class="n">num_regions</span><span class="p">],</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span>
    <span class="p">)</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">regions</span><span class="p">)</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="c1"># next 2 lines omitted in discretize_overlap</span>
    <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
        <span class="n">subsys_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ppp2pwa</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subsys_list</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">ssys</span>
    <span class="c1"># init graphics</span>
    <span class="k">if</span> <span class="n">plotit</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
            <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
            <span class="n">file_extension</span> <span class="o">=</span> <span class="s1">&#39;pdf&#39;</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;failed to import matplotlib&#39;</span><span class="p">)</span>
            <span class="n">plt</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">iter_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># List of how many &quot;new&quot; regions</span>
    <span class="c1"># have been created for each region</span>
    <span class="c1"># and a list of original number of neighbors</span>
    <span class="c1">#num_new_reg = np.zeros(len(orig_list))</span>
    <span class="c1">#num_orig_neigh = np.sum(adj, axis=1).flatten() - 1</span>
    <span class="n">progress</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># Do the abstraction</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span>
        <span class="c1"># i,j swapped in discretize_overlap</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">IJ</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">sj</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">si_tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
        <span class="n">sj_tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">sj</span><span class="p">)</span>
        <span class="c1">#num_new_reg[i] += 1</span>
        <span class="c1">#print(num_new_reg)</span>
        <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="n">ssys</span><span class="o">.</span><span class="n">list_subsys</span><span class="p">[</span><span class="n">subsys_list</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rd</span><span class="p">,</span> <span class="n">xd</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">Wset</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rd</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="n">conservative</span><span class="p">:</span>
            <span class="c1"># Don&#39;t use trans_set</span>
            <span class="n">trans_set</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use original cell as trans_set</span>
            <span class="n">trans_set</span> <span class="o">=</span> <span class="n">orig_list</span><span class="p">[</span><span class="n">orig</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">S0</span> <span class="o">=</span> <span class="n">solve_feasible</span><span class="p">(</span>
            <span class="n">si</span><span class="p">,</span> <span class="n">sj</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">closed_loop</span><span class="p">,</span>
            <span class="n">use_all_horizon</span><span class="p">,</span> <span class="n">trans_set</span><span class="p">,</span> <span class="n">max_num_poly</span>
        <span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Working with partition cells: </span><span class="si">{i}</span><span class="s1">, </span><span class="si">{j}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                                                <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="si">{i}</span><span class="s1"> (#polytopes = </span><span class="si">{num}</span><span class="s1">), and:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                                                <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">si</span><span class="p">))</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="si">{j}</span><span class="s1"> (#polytopes = </span><span class="si">{num}</span><span class="s1">)</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
                                                <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">sj</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> with active subsystem: &#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">{sys}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sys</span><span class="o">=</span><span class="n">subsys_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Computed reachable set S0 with volume: &#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">{vol}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vol</span><span class="o">=</span><span class="n">S0</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1">#logger.debug(r&#39;si \cap s0&#39;)</span>
        <span class="n">isect</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">S0</span><span class="p">)</span>
        <span class="n">vol1</span> <span class="o">=</span> <span class="n">isect</span><span class="o">.</span><span class="n">volume</span>
        <span class="n">risect</span><span class="p">,</span> <span class="n">xi</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
        <span class="c1">#logger.debug(r&#39;si \ s0&#39;)</span>
        <span class="n">rsi</span><span class="p">,</span> <span class="n">xd</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
        <span class="n">vol2</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">volume</span><span class="o">-</span><span class="n">vol1</span> <span class="c1"># not accurate. need to check polytope class</span>
        <span class="k">if</span> <span class="n">vol1</span> <span class="o">&lt;=</span> <span class="n">min_cell_volume</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> too small: si </span><span class="se">\\</span><span class="s1">cap Pre(sj), &#39;</span>
                           <span class="s1">&#39;so discard intersection&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vol1</span> <span class="o">&lt;=</span> <span class="n">min_cell_volume</span> <span class="ow">and</span> <span class="n">isect</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> discarded non-empty intersection: &#39;</span>
                           <span class="s1">&#39;consider reducing min_cell_volume&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vol2</span> <span class="o">&lt;=</span> <span class="n">min_cell_volume</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> too small: si </span><span class="se">\\</span><span class="s1"> Pre(sj), so not reached it&#39;</span><span class="p">)</span>
        <span class="c1"># indicate if S0 has exists in sol</span>
        <span class="n">check_isect</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># We don&#39;t want our partitions to be smaller than the disturbance set</span>
        <span class="c1"># Could be a problem since cheby radius is calculated for smallest</span>
        <span class="c1"># convex polytope, so if we have a region we might throw away a good</span>
        <span class="c1"># cell.</span>
        <span class="k">if</span> <span class="p">(</span>
                <span class="n">vol1</span> <span class="o">&gt;</span> <span class="n">min_cell_volume</span> <span class="ow">and</span>
                <span class="n">risect</span> <span class="o">&gt;</span> <span class="n">rd</span> <span class="ow">and</span>
                <span class="n">vol2</span> <span class="o">&gt;</span> <span class="n">min_cell_volume</span> <span class="ow">and</span>
                <span class="n">rsi</span> <span class="o">&gt;</span> <span class="n">rd</span><span class="p">):</span>
            <span class="c1"># check if the intersection has existed in current partitions</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)):</span>
                <span class="k">if</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">isect</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Found: </span><span class="si">{idx}</span><span class="s1"> ---&gt; </span><span class="si">{j}</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span>
                                <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">))</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;intersection exists.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">check_isect</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">check_isect</span><span class="p">:</span>
                <span class="c1"># Make sure new areas are Regions and add proposition lists</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">isect</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">Region</span><span class="p">([</span><span class="n">isect</span><span class="p">],</span> <span class="n">si</span><span class="o">.</span><span class="n">props</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">isect</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># add intersection in sol</span>
                <span class="n">isect_list</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
                <span class="n">sol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isect_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">n_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
                <span class="n">new_idx</span> <span class="o">=</span> <span class="n">n_cells</span><span class="o">-</span><span class="mi">1</span>
                <span class="sd">&quot;&quot;&quot;Update adjacency matrix&quot;&quot;&quot;</span>
                <span class="n">old_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
                <span class="c1"># cell i and new_idx are adjacent</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">new_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">new_idx</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">conservative</span><span class="p">:</span>
                    <span class="n">orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">orig</span><span class="p">,</span> <span class="n">orig</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t\n</span><span class="s1"> Adding states </span><span class="si">{new_idx}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_idx</span><span class="o">=</span>
                                               <span class="n">new_idx</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">old_adj</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n_cells</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="c1"># Every &quot;old&quot; neighbor must be the neighbor</span>
                    <span class="c1"># of at least one of the new</span>
                    <span class="k">if</span> <span class="n">pc</span><span class="o">.</span><span class="n">is_adjacent</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">new_idx</span><span class="p">],</span> <span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">new_idx</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">remove_trans</span> <span class="ow">and</span> <span class="p">(</span><span class="n">trans_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="c1"># Actively remove transitions between non-neighbors</span>
                        <span class="n">transitions</span><span class="p">[</span><span class="n">new_idx</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">transitions</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="sd">&quot;&quot;&quot;Update transition matrix&quot;&quot;&quot;</span>
                <span class="n">transitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">transitions</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
                <span class="n">adj_k</span> <span class="o">=</span> <span class="n">reachable_within</span><span class="p">(</span><span class="n">trans_length</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">adj</span><span class="p">)</span>
                <span class="c1"># transitions i ---&gt; k for k is neighbor of new_idx should be</span>
                <span class="c1"># kept by new_idx</span>
                <span class="n">transitions</span><span class="p">[:,</span> <span class="n">new_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">transitions</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                           <span class="n">adj_k</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                <span class="c1"># if j and new_idx are neighbor, then add new_idx ---&gt; j</span>
                <span class="k">if</span> <span class="n">adj_k</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="sd">&quot;&quot;&quot;Update IJ matrix&quot;&quot;&quot;</span>
                <span class="n">IJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
                <span class="n">sym_adj_change</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="n">adj_k</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">sym_adj_change</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="n">adj_k</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1"> Updated adj: </span><span class="se">\n</span><span class="si">{adj}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">adj</span><span class="o">=</span><span class="n">adj</span><span class="p">)</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1"> Updated trans: </span><span class="se">\n</span><span class="si">{trans}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trans</span><span class="o">=</span>
                                                  <span class="n">transitions</span><span class="p">)</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1"> Updated IJ: </span><span class="se">\n</span><span class="si">{IJ}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">IJ</span><span class="o">=</span><span class="n">IJ</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Divided region: </span><span class="si">{i}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">vol2</span> <span class="o">&lt;</span> <span class="n">abs_tol</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Found: </span><span class="si">{i}</span><span class="s1"> ---&gt; </span><span class="si">{j}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">))</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Unreachable: </span><span class="si">{i}</span><span class="s1"> --X--&gt; </span><span class="si">{j}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1"> diff vol: </span><span class="si">{vol2}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vol2</span><span class="o">=</span><span class="n">vol2</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1"> intersect vol: </span><span class="si">{vol1}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vol1</span><span class="o">=</span><span class="n">vol1</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> unreachable</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># check to avoid overlapping Regions</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">tmp_part</span> <span class="o">=</span> <span class="n">PropPreservingPartition</span><span class="p">(</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                <span class="n">regions</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span> <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span>
                <span class="n">prop_regions</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span>
            <span class="p">)</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">tmp_part</span><span class="o">.</span><span class="n">is_partition</span><span class="p">()</span> <span class="p">)</span>
        <span class="n">n_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
        <span class="n">progress_ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span><span class="n">n_cells</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">progress</span> <span class="o">+=</span> <span class="p">[</span><span class="n">progress_ratio</span><span class="p">]</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> total # polytopes: </span><span class="si">{n_cells}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_cells</span><span class="o">=</span><span class="n">n_cells</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> progress ratio: </span><span class="si">{pr}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pr</span><span class="o">=</span><span class="n">progress_ratio</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">iter_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># needs to be removed later</span>
<span class="c1">#        if(iter_count&gt;=700):</span>
<span class="c1">#            break</span>
        <span class="c1"># no plotting ?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">plotit</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">plt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">plot_partition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">iter_count</span> <span class="o">%</span> <span class="n">plot_every</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">tmp_part</span> <span class="o">=</span> <span class="n">PropPreservingPartition</span><span class="p">(</span>
            <span class="n">domain</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
            <span class="n">regions</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span> <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span>
            <span class="n">prop_regions</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span>
        <span class="p">)</span>
        <span class="c1"># plot pair under reachability check</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">si_tmp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>
        <span class="n">sj_tmp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">plot_transition_arrow</span><span class="p">(</span><span class="n">si_tmp</span><span class="p">,</span> <span class="n">sj_tmp</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span>
        <span class="n">S0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="c1"># plot partition</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">plot_partition</span><span class="p">(</span><span class="n">tmp_part</span><span class="p">,</span> <span class="n">transitions</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span> <span class="n">color_seed</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
        <span class="c1"># plot dynamics</span>
        <span class="n">ssys</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">show_domain</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># plot hatched continuous propositions</span>
        <span class="n">part</span><span class="o">.</span><span class="n">plot_props</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="c1"># scale view based on domain,</span>
        <span class="c1"># not only the current polytopes si, sj</span>
        <span class="n">l</span><span class="p">,</span><span class="n">u</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">save_img</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;movie&#39;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iter_count</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">fname</span> <span class="o">+=</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">file_extension</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">250</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">new_part</span> <span class="o">=</span> <span class="n">PropPreservingPartition</span><span class="p">(</span>
        <span class="n">domain</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
        <span class="n">regions</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span> <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span>
        <span class="n">prop_regions</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span>
    <span class="p">)</span>
    <span class="c1"># check completeness of adjacency matrix</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">tmp_part</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">new_part</span><span class="p">)</span>
        <span class="n">tmp_part</span><span class="o">.</span><span class="n">compute_adj</span><span class="p">()</span>
    <span class="c1"># Generate transition system and add transitions</span>
    <span class="n">ofts</span> <span class="o">=</span> <span class="n">trs</span><span class="o">.</span><span class="n">FTS</span><span class="p">()</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">transitions</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ofts_states</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">ofts</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">ofts_states</span><span class="p">)</span>
    <span class="n">ofts</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">add_adj</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">ofts_states</span><span class="p">)</span>
    <span class="c1"># Decorate TS with state labels</span>
    <span class="n">atomic_propositions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">)</span>
    <span class="n">ofts</span><span class="o">.</span><span class="n">atomic_propositions</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">atomic_propositions</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ofts_states</span><span class="p">,</span> <span class="n">sol</span><span class="p">):</span>
        <span class="n">state_prop</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ofts</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">ap</span><span class="o">=</span><span class="n">state_prop</span><span class="p">)</span>
    <span class="n">param</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;N&#39;</span><span class="p">:</span><span class="n">N</span><span class="p">,</span>
        <span class="s1">&#39;trans_length&#39;</span><span class="p">:</span><span class="n">trans_length</span><span class="p">,</span>
        <span class="s1">&#39;closed_loop&#39;</span><span class="p">:</span><span class="n">closed_loop</span><span class="p">,</span>
        <span class="s1">&#39;conservative&#39;</span><span class="p">:</span><span class="n">conservative</span><span class="p">,</span>
        <span class="s1">&#39;use_all_horizon&#39;</span><span class="p">:</span><span class="n">use_all_horizon</span><span class="p">,</span>
        <span class="s1">&#39;min_cell_volume&#39;</span><span class="p">:</span><span class="n">min_cell_volume</span><span class="p">,</span>
        <span class="s1">&#39;max_num_poly&#39;</span><span class="p">:</span><span class="n">max_num_poly</span>
    <span class="p">}</span>
    <span class="n">ppp2orig</span> <span class="o">=</span> <span class="p">[</span><span class="n">part2orig</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">orig</span><span class="p">]</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Total abstraction time: </span><span class="si">{t}</span><span class="s1"> [sec]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">t</span><span class="o">=</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">save_img</span> <span class="ow">and</span> <span class="n">plt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;iteration&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;progress ratio&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;progress.pdf&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AbstractPwa</span><span class="p">(</span>
        <span class="n">ppp</span><span class="o">=</span><span class="n">new_part</span><span class="p">,</span>
        <span class="n">ts</span><span class="o">=</span><span class="n">ofts</span><span class="p">,</span>
        <span class="n">ppp2ts</span><span class="o">=</span><span class="n">ofts_states</span><span class="p">,</span>
        <span class="n">pwa</span><span class="o">=</span><span class="n">ssys</span><span class="p">,</span>
        <span class="n">pwa_ppp</span><span class="o">=</span><span class="n">part</span><span class="p">,</span>
        <span class="n">ppp2pwa</span><span class="o">=</span><span class="n">orig</span><span class="p">,</span>
        <span class="n">ppp2sys</span><span class="o">=</span><span class="n">subsys_list</span><span class="p">,</span>
        <span class="n">orig_ppp</span><span class="o">=</span><span class="n">orig_ppp</span><span class="p">,</span>
        <span class="n">ppp2orig</span><span class="o">=</span><span class="n">ppp2orig</span><span class="p">,</span>
        <span class="n">disc_params</span><span class="o">=</span><span class="n">param</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">reachable_within</span><span class="p">(</span><span class="n">trans_length</span><span class="p">,</span> <span class="n">adj_k</span><span class="p">,</span> <span class="n">adj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find cells reachable within trans_length hops.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">trans_length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adj_k</span>

    <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">trans_length</span><span class="p">:</span>
        <span class="n">adj_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">adj_k</span><span class="p">,</span> <span class="n">adj</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">adj_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">adj_k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">adj_k</span>

<span class="k">def</span> <span class="nf">sym_adj_change</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="n">adj_k</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">horizontal</span> <span class="o">=</span> <span class="n">adj_k</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span><span class="n">transitions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">vertical</span> <span class="o">=</span> <span class="n">adj_k</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span><span class="n">transitions</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="n">IJ</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">horizontal</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">IJ</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertical</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

<span class="c1"># DEFUNCT until further notice</span>
<span class="k">def</span> <span class="nf">discretize_overlap</span><span class="p">(</span><span class="n">closed_loop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conservative</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;default False.</span>

<span class="sd">    UNDER DEVELOPMENT; function signature may change without notice.</span>
<span class="sd">    Calling will result in NotImplementedError.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
<span class="c1">#</span>
<span class="c1">#         if rdiff &lt; abs_tol:</span>
<span class="c1">#             logger.info(&quot;Transition found&quot;)</span>
<span class="c1">#             transitions[i,j] = 1</span>
<span class="c1">#</span>
<span class="c1">#         elif ((vol1 &gt; min_cell_volume) &amp; (risect &gt; rd) &amp;</span>
<span class="c1">#                 (num_new_reg[i] &lt;= num_orig_neigh[i]+1)):</span>
<span class="c1">#</span>
<span class="c1">#             # Make sure new cell is Region and add proposition lists</span>
<span class="c1">#             if len(isect) == 0:</span>
<span class="c1">#                 isect = pc.Region([isect], si.props)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 isect.props = si.props.copy()</span>
<span class="c1">#</span>
<span class="c1">#             # Add new state</span>
<span class="c1">#             sol.append(isect)</span>
<span class="c1">#             size = len(sol)</span>
<span class="c1">#</span>
<span class="c1">#             # Add transitions</span>
<span class="c1">#             transitions = np.hstack([transitions, np.zeros([size - 1, 1],</span>
<span class="c1">#                                     dtype=int) ])</span>
<span class="c1">#             transitions = np.vstack([transitions, np.zeros([1, size],</span>
<span class="c1">#                                     dtype=int) ])</span>
<span class="c1">#</span>
<span class="c1">#             # All sets reachable from orig cell are reachable from both cells</span>
<span class="c1">#             transitions[size-1,:] = transitions[i,:]</span>
<span class="c1">#             transitions[size-1,j] = 1   # j is reachable from new cell</span>
<span class="c1">#</span>
<span class="c1">#             # Take care of adjacency</span>
<span class="c1">#             old_adj = np.nonzero(adj[i,:])[0]</span>
<span class="c1">#</span>
<span class="c1">#             adj = np.hstack([adj, np.zeros([size - 1, 1], dtype=int) ])</span>
<span class="c1">#             adj = np.vstack([adj, np.zeros([1, size], dtype=int) ])</span>
<span class="c1">#             adj[i,size-1] = 1</span>
<span class="c1">#             adj[size-1,i] = 1</span>
<span class="c1">#             adj[size-1,size-1] = 1</span>
<span class="c1">#</span>
<span class="c1">#             for k in np.setdiff1d(old_adj,[i,size-1]):</span>
<span class="c1">#                 if pc.is_adjacent(sol[size-1],sol[k],overlap=True):</span>
<span class="c1">#                     adj[size-1,k] = 1</span>
<span class="c1">#                     adj[k, size-1] = 1</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     # Actively remove (valid) transitions between non-neighbors</span>
<span class="c1">#                     transitions[size-1,k] = 0</span>
<span class="c1">#                     transitions[k,size-1] = 0</span>
<span class="c1">#</span>
<span class="c1">#             # Assign original proposition cell to new state and update counts</span>
<span class="c1">#             if not conservative:</span>
<span class="c1">#                 orig = np.hstack([orig, orig[i]])</span>
<span class="c1">#             print(num_new_reg)</span>
<span class="c1">#             num_new_reg = np.hstack([num_new_reg, 0])</span>
<span class="c1">#             num_orig_neigh = np.hstack([num_orig_neigh, np.sum(adj[size-1,:])-1])</span>
<span class="c1">#</span>
<span class="c1">#             logger.info(&quot;\n Adding state &quot; + str(size-1) + &quot;\n&quot;)</span>
<span class="c1">#</span>
<span class="c1">#             # Just add adjacent cells for checking,</span>
<span class="c1">#             # unless transition already found</span>
<span class="c1">#             IJ = np.hstack([IJ, np.zeros([size - 1, 1], dtype=int) ])</span>
<span class="c1">#             IJ = np.vstack([IJ, np.zeros([1, size], dtype=int) ])</span>
<span class="c1">#             horiz2 = adj[size-1,:] - transitions[size-1,:] &gt; 0</span>
<span class="c1">#             verti2 = adj[:,size-1] - transitions[:,size-1] &gt; 0</span>
<span class="c1">#             IJ[size-1,:] = horiz2.astype(int)</span>
<span class="c1">#             IJ[:,size-1] = verti2.astype(int)</span>
<span class="c1">#         else:</span>
<span class="c1">#             logger.info(&quot;No transition found, intersect vol: &quot; + str(vol1) )</span>
<span class="c1">#             transitions[i,j] = 0</span>
<span class="c1">#</span>
<span class="c1">#     new_part = PropPreservingPartition(</span>
<span class="c1">#                    domain=part.domain,</span>
<span class="c1">#                    regions=sol, adj=np.array([]),</span>
<span class="c1">#                    trans=transitions, prop_regions=part.prop_regions,</span>
<span class="c1">#                    original_regions=orig_list, orig=orig)</span>
<span class="c1">#     return new_part</span>

<span class="k">def</span> <span class="nf">multiproc_discretize</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ppp</span><span class="p">,</span> <span class="n">cont_dyn</span><span class="p">,</span> <span class="n">disc_params</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">logger</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">log_to_stderr</span><span class="p">()</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Abstracting mode: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, on: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="n">absys</span> <span class="o">=</span> <span class="n">discretize</span><span class="p">(</span><span class="n">ppp</span><span class="p">,</span> <span class="n">cont_dyn</span><span class="p">,</span> <span class="o">**</span><span class="n">disc_params</span><span class="p">)</span>

    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">mode</span><span class="p">,</span> <span class="n">absys</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Worker: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;finished.&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">multiproc_get_transitions</span><span class="p">(</span>
    <span class="n">q</span><span class="p">,</span> <span class="n">absys</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">params</span>
<span class="p">):</span>
    <span class="k">global</span> <span class="n">logger</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">log_to_stderr</span><span class="p">()</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Merged transitions for mode: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, on: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="n">trans</span> <span class="o">=</span> <span class="n">get_transitions</span><span class="p">(</span><span class="n">absys</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">mode</span><span class="p">,</span> <span class="n">trans</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Worker: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;finished.&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">multiproc_discretize_switched</span><span class="p">(</span>
    <span class="n">ppp</span><span class="p">,</span> <span class="n">hybrid_sys</span><span class="p">,</span> <span class="n">disc_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_ts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parallel implementation of discretize_switched.</span>

<span class="sd">    Uses the multiprocessing package.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;parallel discretize_switched started&#39;</span><span class="p">)</span>

    <span class="n">modes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hybrid_sys</span><span class="o">.</span><span class="n">modes</span><span class="p">)</span>
    <span class="n">mode_nums</span> <span class="o">=</span> <span class="n">hybrid_sys</span><span class="o">.</span><span class="n">disc_domain_size</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>

    <span class="n">mode_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="n">cont_dyn</span> <span class="o">=</span> <span class="n">hybrid_sys</span><span class="o">.</span><span class="n">dynamics</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">mode_args</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ppp</span><span class="p">,</span> <span class="n">cont_dyn</span><span class="p">,</span> <span class="n">disc_params</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>

    <span class="n">jobs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">multiproc_discretize</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">mode_args</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
        <span class="n">job</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="c1"># flush before join:</span>
    <span class="c1">#   http://stackoverflow.com/questions/19071529/</span>
    <span class="n">abstractions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
        <span class="n">mode</span><span class="p">,</span> <span class="n">absys</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">abstractions</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">absys</span>

    <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
        <span class="n">job</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="c1"># merge their domains</span>
    <span class="p">(</span><span class="n">merged_abstr</span><span class="p">,</span> <span class="n">ap_labeling</span><span class="p">)</span> <span class="o">=</span> <span class="n">merge_partitions</span><span class="p">(</span><span class="n">abstractions</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_abstr</span><span class="o">.</span><span class="n">ppp</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Merged partition has: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, states&#39;</span><span class="p">)</span>

    <span class="c1"># find feasible transitions over merged partition</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="n">cont_dyn</span> <span class="o">=</span> <span class="n">hybrid_sys</span><span class="o">.</span><span class="n">dynamics</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">disc_params</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>

        <span class="n">mode_args</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">merged_abstr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cont_dyn</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

    <span class="n">jobs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">multiproc_get_transitions</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">mode_args</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

    <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
        <span class="n">job</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="n">trans</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
        <span class="n">mode</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">trans</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>

    <span class="c1"># merge the abstractions, creating a common TS</span>
    <span class="n">merge_abstractions</span><span class="p">(</span><span class="n">merged_abstr</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
                       <span class="n">abstractions</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">mode_nums</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plot_mode_partitions</span><span class="p">(</span><span class="n">merged_abstr</span><span class="p">,</span> <span class="n">show_ts</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">merged_abstr</span>

<span class="k">def</span> <span class="nf">discretize_switched</span><span class="p">(</span>
    <span class="n">ppp</span><span class="p">,</span> <span class="n">hybrid_sys</span><span class="p">,</span> <span class="n">disc_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_ts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract switched dynamics over given partition.</span>

<span class="sd">    @type ppp: L{PropPreservingPartition}</span>

<span class="sd">    @param hybrid_sys: dynamics of switching modes</span>
<span class="sd">    @type hybrid_sys: L{SwitchedSysDyn}</span>

<span class="sd">    @param disc_params: discretization parameters passed to L{discretize} for</span>
<span class="sd">		each mode. See L{discretize} for details.</span>
<span class="sd">    @type disc_params: dict (keyed by mode) of dicts.</span>

<span class="sd">    @param plot: save partition images</span>
<span class="sd">    @type plot: bool</span>

<span class="sd">    @param show_ts, only_adjacent: options for L{AbstractPwa.plot}.</span>

<span class="sd">    @return: abstracted dynamics,</span>
<span class="sd">        some attributes are dict keyed by mode</span>
<span class="sd">    @rtype: L{AbstractSwitched}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">disc_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">disc_params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;N&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;trans_length&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;discretizing hybrid system&#39;</span><span class="p">)</span>

    <span class="n">modes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hybrid_sys</span><span class="o">.</span><span class="n">modes</span><span class="p">)</span>
    <span class="n">mode_nums</span> <span class="o">=</span> <span class="n">hybrid_sys</span><span class="o">.</span><span class="n">disc_domain_size</span>

    <span class="c1"># discretize each abstraction separately</span>
    <span class="n">abstractions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="mi">30</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Abstracting mode: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

        <span class="n">cont_dyn</span> <span class="o">=</span> <span class="n">hybrid_sys</span><span class="o">.</span><span class="n">dynamics</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>

        <span class="n">absys</span> <span class="o">=</span> <span class="n">discretize</span><span class="p">(</span>
            <span class="n">ppp</span><span class="p">,</span> <span class="n">cont_dyn</span><span class="p">,</span>
            <span class="o">**</span><span class="n">disc_params</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Mode Abstraction:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">absys</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">abstractions</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">absys</span>

    <span class="c1"># merge their domains</span>
    <span class="p">(</span><span class="n">merged_abstr</span><span class="p">,</span> <span class="n">ap_labeling</span><span class="p">)</span> <span class="o">=</span> <span class="n">merge_partitions</span><span class="p">(</span><span class="n">abstractions</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_abstr</span><span class="o">.</span><span class="n">ppp</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Merged partition has: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, states&#39;</span><span class="p">)</span>

    <span class="c1"># find feasible transitions over merged partition</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="n">cont_dyn</span> <span class="o">=</span> <span class="n">hybrid_sys</span><span class="o">.</span><span class="n">dynamics</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">disc_params</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>

        <span class="n">trans</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_transitions</span><span class="p">(</span>
            <span class="n">merged_abstr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cont_dyn</span><span class="p">,</span>
            <span class="n">N</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">],</span> <span class="n">trans_length</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;trans_length&#39;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="c1"># merge the abstractions, creating a common TS</span>
    <span class="n">merge_abstractions</span><span class="p">(</span><span class="n">merged_abstr</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
                       <span class="n">abstractions</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">mode_nums</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plot_mode_partitions</span><span class="p">(</span><span class="n">merged_abstr</span><span class="p">,</span> <span class="n">show_ts</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">merged_abstr</span>

<span class="k">def</span> <span class="nf">plot_mode_partitions</span><span class="p">(</span><span class="n">swab</span><span class="p">,</span> <span class="n">show_ts</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Save each mode&#39;s partition and final merged partition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">axs</span> <span class="o">=</span> <span class="n">swab</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">show_ts</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">axs</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;failed to plot the partitions.&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">swab</span><span class="o">.</span><span class="n">modes</span><span class="p">)</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># annotate</span>
    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axs</span><span class="p">:</span>
        <span class="n">plot_annot</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

    <span class="c1"># save mode partitions</span>
    <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axs</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">swab</span><span class="o">.</span><span class="n">modes</span><span class="p">):</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;merged_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.pdf&#39;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

    <span class="c1"># save merged partition</span>
    <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">n</span><span class="p">:],</span> <span class="n">swab</span><span class="o">.</span><span class="n">modes</span><span class="p">):</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;part_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.pdf&#39;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">plot_annot</span><span class="p">(</span><span class="n">ax</span><span class="p">):</span>
    <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="k">for</span> <span class="n">tick</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">():</span>
        <span class="n">tick</span><span class="o">.</span><span class="n">label1</span><span class="o">.</span><span class="n">set_fontsize</span><span class="p">(</span><span class="n">fontsize</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">tick</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">():</span>
        <span class="n">tick</span><span class="o">.</span><span class="n">label1</span><span class="o">.</span><span class="n">set_fontsize</span><span class="p">(</span><span class="n">fontsize</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$v_1$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="o">+</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$v_2$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="o">+</span><span class="mi">6</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">merge_abstractions</span><span class="p">(</span><span class="n">merged_abstr</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">abstr</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">mode_nums</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Construct merged transitions.</span>

<span class="sd">    @type merged_abstr: L{AbstractSwitched}</span>
<span class="sd">    @type abstr: dict of L{AbstractPwa}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: check equality of atomic proposition sets</span>
    <span class="n">aps</span> <span class="o">=</span> <span class="n">abstr</span><span class="p">[</span><span class="n">modes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">atomic_propositions</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;APs: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">aps</span><span class="p">))</span>

    <span class="n">sys_ts</span> <span class="o">=</span> <span class="n">trs</span><span class="o">.</span><span class="n">FTS</span><span class="p">()</span>

    <span class="c1"># create stats</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_abstr</span><span class="o">.</span><span class="n">ppp</span><span class="p">)</span>
    <span class="n">states</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">sys_ts</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

    <span class="n">sys_ts</span><span class="o">.</span><span class="n">atomic_propositions</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">aps</span><span class="p">)</span>

    <span class="c1"># copy AP labels from regions to discrete states</span>
    <span class="n">ppp2ts</span> <span class="o">=</span> <span class="n">states</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ppp2ts</span><span class="p">):</span>
        <span class="n">props</span> <span class="o">=</span>  <span class="n">merged_abstr</span><span class="o">.</span><span class="n">ppp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">props</span>
        <span class="n">sys_ts</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="s1">&#39;ap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">props</span>

    <span class="c1"># create mode actions</span>
    <span class="n">sys_actions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">]</span>
    <span class="n">env_actions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">]</span>

    <span class="c1"># no env actions ?</span>
    <span class="k">if</span> <span class="n">mode_nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">actions_per_mode</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">):{</span><span class="s1">&#39;sys_actions&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">e</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="n">modes</span>
        <span class="p">}</span>
        <span class="n">sys_ts</span><span class="o">.</span><span class="n">sys_actions</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">sys_actions</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode_nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># no sys actions</span>
        <span class="n">actions_per_mode</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">):{</span><span class="s1">&#39;env_actions&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">e</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="n">modes</span>
        <span class="p">}</span>
        <span class="n">sys_ts</span><span class="o">.</span><span class="n">env_actions</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">env_actions</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">actions_per_mode</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">s</span><span class="p">):{</span><span class="s1">&#39;env_actions&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="s1">&#39;sys_actions&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">e</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="n">modes</span>
        <span class="p">}</span>
        <span class="n">sys_ts</span><span class="o">.</span><span class="n">env_actions</span><span class="o">.</span><span class="n">add_from</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">])</span>
        <span class="n">sys_ts</span><span class="o">.</span><span class="n">sys_actions</span><span class="o">.</span><span class="n">add_from</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="n">env_sys_actions</span> <span class="o">=</span> <span class="n">actions_per_mode</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="n">trans</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>

        <span class="n">sys_ts</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">add_adj</span><span class="p">(</span>
            <span class="n">adj</span> <span class="o">=</span> <span class="n">adj</span><span class="p">,</span>
            <span class="n">adj2states</span> <span class="o">=</span> <span class="n">states</span><span class="p">,</span>
            <span class="o">**</span><span class="n">env_sys_actions</span>
        <span class="p">)</span>

    <span class="n">merged_abstr</span><span class="o">.</span><span class="n">ts</span> <span class="o">=</span> <span class="n">sys_ts</span>
    <span class="n">merged_abstr</span><span class="o">.</span><span class="n">ppp2ts</span> <span class="o">=</span> <span class="n">ppp2ts</span>

<span class="k">def</span> <span class="nf">get_transitions</span><span class="p">(</span>
    <span class="n">abstract_sys</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">closed_loop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">trans_length</span><span class="o">=</span><span class="mi">1</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find which transitions are feasible in given mode.</span>

<span class="sd">    Used for the candidate transitions of the merged partition.</span>

<span class="sd">    @rtype: scipy.sparse.lil_matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;checking which transitions remain feasible after merging&#39;</span><span class="p">)</span>
    <span class="n">part</span> <span class="o">=</span> <span class="n">abstract_sys</span><span class="o">.</span><span class="n">ppp</span>

    <span class="c1"># Initialize matrix for pairs to check</span>
    <span class="n">IJ</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">trans_length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">trans_length</span><span class="p">:</span>
            <span class="n">IJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">IJ</span> <span class="o">=</span> <span class="p">(</span><span class="n">IJ</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Initialize output</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
    <span class="n">transitions</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Do the abstraction</span>
    <span class="n">n_checked</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_found</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_checked</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">IJ</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;checking transition: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; -&gt; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>

        <span class="n">si</span> <span class="o">=</span> <span class="n">part</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">sj</span> <span class="o">=</span> <span class="n">part</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="c1"># Use original cell as trans_set</span>
        <span class="n">trans_set</span> <span class="o">=</span> <span class="n">abstract_sys</span><span class="o">.</span><span class="n">ppp2pwa</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">active_subsystem</span> <span class="o">=</span> <span class="n">abstract_sys</span><span class="o">.</span><span class="n">ppp2sys</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">trans_feasible</span> <span class="o">=</span> <span class="n">is_feasible</span><span class="p">(</span>
            <span class="n">si</span><span class="p">,</span> <span class="n">sj</span><span class="p">,</span> <span class="n">active_subsystem</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span>
            <span class="n">closed_loop</span> <span class="o">=</span> <span class="n">closed_loop</span><span class="p">,</span>
            <span class="n">trans_set</span> <span class="o">=</span> <span class="n">trans_set</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">trans_feasible</span><span class="p">:</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Feasible transition.&#39;</span>
            <span class="n">n_found</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Not feasible transition.&#39;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Checked: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_checked</span><span class="p">))</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Found: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_found</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">n_checked</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;would divide &#39;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Survived merging: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n_found</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_checked</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; % &#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">transitions</span>

<span class="k">def</span> <span class="nf">multiproc_merge_partitions</span><span class="p">(</span><span class="n">abstractions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;LOGTIME in #processors parallel merging.</span>

<span class="sd">    Assuming sufficient number of processors.</span>

<span class="sd">    UNDER DEVELOPMENT; function signature may change without notice.</span>
<span class="sd">    Calling will result in NotImplementedError.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<span class="k">def</span> <span class="nf">merge_partitions</span><span class="p">(</span><span class="n">abstractions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merge multiple abstractions.</span>

<span class="sd">    @param abstractions: keyed by mode</span>
<span class="sd">    @type abstractions: dict of L{AbstractPwa}</span>

<span class="sd">    @return: (merged_abstraction, ap_labeling)</span>
<span class="sd">        where:</span>
<span class="sd">            - merged_abstraction: L{AbstractSwitched}</span>
<span class="sd">            - ap_labeling: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">abstractions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Abstractions empty, nothing to merge.&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># consistency check</span>
    <span class="k">for</span> <span class="n">ab1</span> <span class="ow">in</span> <span class="n">abstractions</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">ab2</span> <span class="ow">in</span> <span class="n">abstractions</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">ab1</span><span class="o">.</span><span class="n">ppp</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">ab2</span><span class="o">.</span><span class="n">ppp</span>

            <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">prop_regions</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;merge: partitions have different sets &#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;of continuous propositions&#39;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">A</span> <span class="o">==</span> <span class="n">p2</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">b</span> <span class="o">==</span> <span class="n">p2</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;merge: partitions have different domains&#39;</span><span class="p">)</span>

            <span class="c1"># check equality of original PPP partitions</span>
            <span class="k">if</span> <span class="n">ab1</span><span class="o">.</span><span class="n">orig_ppp</span> <span class="o">==</span> <span class="n">ab2</span><span class="o">.</span><span class="n">orig_ppp</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;original partitions happen to be equal&#39;</span><span class="p">)</span>

    <span class="n">init_mode</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">abstractions</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">all_modes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">abstractions</span><span class="p">)</span>
    <span class="n">remaining_modes</span> <span class="o">=</span> <span class="n">all_modes</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">init_mode</span><span class="p">]))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;init mode: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">init_mode</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;all modes: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">all_modes</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;remaining modes: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">remaining_modes</span><span class="p">))</span>

    <span class="c1"># initialize iteration data</span>
    <span class="n">prev_modes</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_mode</span><span class="p">]</span>

   	<span class="c1"># Create a list of merged-together regions</span>
    <span class="n">ab0</span> <span class="o">=</span> <span class="n">abstractions</span><span class="p">[</span><span class="n">init_mode</span><span class="p">]</span>
    <span class="n">regions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ab0</span><span class="o">.</span><span class="n">ppp</span><span class="p">)</span>
    <span class="n">parents</span> <span class="o">=</span> <span class="p">{</span><span class="n">init_mode</span><span class="p">:</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span> <span class="p">))}</span>
    <span class="n">ap_labeling</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="n">reg</span><span class="o">.</span><span class="n">props</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">reg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">regions</span><span class="p">)}</span>
    <span class="k">for</span> <span class="n">cur_mode</span> <span class="ow">in</span> <span class="n">remaining_modes</span><span class="p">:</span>
        <span class="n">ab2</span> <span class="o">=</span> <span class="n">abstractions</span><span class="p">[</span><span class="n">cur_mode</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">merge_partition_pair</span><span class="p">(</span>
            <span class="n">regions</span><span class="p">,</span> <span class="n">ab2</span><span class="p">,</span> <span class="n">cur_mode</span><span class="p">,</span> <span class="n">prev_modes</span><span class="p">,</span>
            <span class="n">parents</span><span class="p">,</span> <span class="n">ap_labeling</span>
        <span class="p">)</span>
        <span class="n">regions</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">ap_labeling</span> <span class="o">=</span> <span class="n">r</span>
        <span class="n">prev_modes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cur_mode</span><span class="p">]</span>
    <span class="n">new_list</span> <span class="o">=</span> <span class="n">regions</span>

    <span class="c1"># build adjacency based on spatial adjacencies of</span>
    <span class="c1"># component abstractions.</span>
    <span class="c1"># which justifies the assumed symmetry of part1.adj, part2.adj</span>
	<span class="c1"># Basically, if two regions are either 1) part of the same region in one of</span>
	<span class="c1"># the abstractions or 2) adjacent in one of the abstractions, then the two</span>
	<span class="c1"># regions are adjacent in the switched dynamics.</span>
    <span class="n">n_reg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_list</span><span class="p">)</span>

    <span class="n">adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_reg</span><span class="p">,</span> <span class="n">n_reg</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reg_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">reg_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_list</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">touching</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">abstractions</span><span class="p">:</span>
                <span class="n">pi</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">pj</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

                <span class="n">part</span> <span class="o">=</span> <span class="n">abstractions</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">ppp</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">pi</span><span class="p">,</span> <span class="n">pj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pi</span> <span class="o">==</span> <span class="n">pj</span><span class="p">):</span>
                    <span class="n">touching</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">touching</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">pc</span><span class="o">.</span><span class="n">is_adjacent</span><span class="p">(</span><span class="n">reg_i</span><span class="p">,</span> <span class="n">reg_j</span><span class="p">):</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">ppp</span> <span class="o">=</span> <span class="n">PropPreservingPartition</span><span class="p">(</span>
        <span class="n">domain</span><span class="o">=</span><span class="n">ab0</span><span class="o">.</span><span class="n">ppp</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
        <span class="n">regions</span><span class="o">=</span><span class="n">new_list</span><span class="p">,</span>
        <span class="n">prop_regions</span><span class="o">=</span><span class="n">ab0</span><span class="o">.</span><span class="n">ppp</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">,</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">adj</span>
    <span class="p">)</span>

    <span class="n">abstraction</span> <span class="o">=</span> <span class="n">AbstractSwitched</span><span class="p">(</span>
        <span class="n">ppp</span><span class="o">=</span><span class="n">ppp</span><span class="p">,</span>
        <span class="n">modes</span><span class="o">=</span><span class="n">abstractions</span><span class="p">,</span>
        <span class="n">ppp2modes</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">abstraction</span><span class="p">,</span> <span class="n">ap_labeling</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">merge_partition_pair</span><span class="p">(</span>
    <span class="n">old_regions</span><span class="p">,</span> <span class="n">ab2</span><span class="p">,</span>
    <span class="n">cur_mode</span><span class="p">,</span> <span class="n">prev_modes</span><span class="p">,</span>
    <span class="n">old_parents</span><span class="p">,</span> <span class="n">old_ap_labeling</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merge an Abstraction with the current partition iterate.</span>

<span class="sd">    @param old_regions: A list of C{Region} that is from either:</span>
<span class="sd">        1. The ppp of the first (initial) L{AbstractPwa} to be merged.</span>
<span class="sd">        2. A list of already-merged regions</span>
<span class="sd">    @type old_regions: list of C{Region}</span>

<span class="sd">    @param ab2: Abstracted piecewise affine dynamics to be merged into the</span>
<span class="sd">    @type ab2: L{AbstractPwa}</span>

<span class="sd">    @param cur_mode: mode to be merged</span>
<span class="sd">    @type cur_mode: tuple</span>

<span class="sd">    @param prev_modes: list of modes that have already been merged together</span>
<span class="sd">    @type prev_modes: list of tuple</span>

<span class="sd">    @param old_parents: dict of modes that have already been merged to dict of</span>
<span class="sd">        indices of new regions to indices of regions</span>
<span class="sd">    @type old_parents: dict of modes to list of region indices in list</span>
<span class="sd">        C{old_regions} or dict of region indices to regions in original ppp for</span>
<span class="sd">        that mode</span>

<span class="sd">    @param old_ap_labeling: dict of states of already-merged modes to sets of</span>
<span class="sd">        propositions for each state</span>
<span class="sd">    @type old_ap_labeling: dict of tuples to sets</span>

<span class="sd">    @return: the following:</span>
<span class="sd">        - C{new_list}, list of new regions</span>
<span class="sd">        - C{parents}, same as input param C{old_parents}, except that it</span>
<span class="sd">          includes the mode that was just merged and for list of regions in</span>
<span class="sd">          return value C{new_list}</span>
<span class="sd">        - C{ap_labeling}, same as input param C{old_ap_labeling}, except that it</span>
<span class="sd">          includes the mode that was just merged.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;merging partitions&#39;</span><span class="p">)</span>

    <span class="n">part2</span> <span class="o">=</span> <span class="n">ab2</span><span class="o">.</span><span class="n">ppp</span>

    <span class="n">modes</span> <span class="o">=</span> <span class="n">prev_modes</span> <span class="o">+</span> <span class="p">[</span><span class="n">cur_mode</span><span class="p">]</span>

    <span class="n">new_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">parents</span> <span class="o">=</span> <span class="p">{</span><span class="n">mode</span><span class="p">:</span><span class="nb">dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">}</span>
    <span class="n">ap_labeling</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old_regions</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">part2</span><span class="p">)):</span>
            <span class="n">isect</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">old_regions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                 <span class="n">part2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">rc</span><span class="p">,</span> <span class="n">xc</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>

            <span class="c1"># no intersection ?</span>
            <span class="k">if</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="mf">1e-5</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;merging region: A&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span>
                        <span class="s1">&#39;, with: B&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>

            <span class="c1"># if Polytope, make it Region</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">isect</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">Region</span><span class="p">([</span><span class="n">isect</span><span class="p">])</span>

            <span class="c1"># label the Region with propositions</span>
            <span class="n">isect</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">old_regions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">new_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">new_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>

            <span class="c1"># keep track of parents</span>
            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">prev_modes</span><span class="p">:</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_parents</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">parents</span><span class="p">[</span><span class="n">cur_mode</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>

            <span class="c1"># union of AP labels from parent states</span>
            <span class="n">ap_label_1</span> <span class="o">=</span> <span class="n">old_ap_labeling</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ap_label_2</span> <span class="o">=</span> <span class="n">ab2</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;ap&#39;</span><span class="p">]</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;AP label 1: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ap_label_1</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;AP label 2: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ap_label_2</span><span class="p">))</span>

            <span class="c1"># original partitions may be different if pwa_partition used</span>
            <span class="c1"># but must originate from same initial partition,</span>
            <span class="c1"># i.e., have same continuous propositions, checked above</span>
            <span class="c1">#</span>
            <span class="c1"># so no two intersecting regions can have different AP labels,</span>
            <span class="c1"># checked here</span>
            <span class="k">if</span> <span class="n">ap_label_1</span> <span class="o">!=</span> <span class="n">ap_label_2</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Inconsistent AP labels between intersecting regions</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;of partitions of switched system.&#39;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="n">ap_labeling</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ap_label_1</span>

    <span class="k">return</span> <span class="n">new_list</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">ap_labeling</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">TuLiP 1.4.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">abstract.discretization</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010-2017, California Institute of Technology.
      Last updated on 05 November 2021.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>